package com.luckyrui.platform.chartroom.client;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.util.Iterator;import java.util.Set;import com.luckyrui.platform.constants.ConfigConts;import com.luckyrui.platform.utils.PropertiesHandler;public abstract class NioClient implements Client {	private String ipAddr;	private Integer port;	public static SelectorLoop readBell;	public boolean isReadBellRunning = false;	SocketChannel socketChannel;		ByteBuffer sendBuffer; 	public NioClient() {		ipAddr = ph.get(ConfigConts.SERVER_IP);		port = Integer.parseInt(ph.get(ConfigConts.SERVER_PORT));	}	@Override	public void start() throws IOException {		// 一个消息轮序线程类,但有新消息时触发		readBell = new SelectorLoop();		init();		socketChannel.register(readBell.getSelector(), SelectionKey.OP_READ);		System.out.println("client connection -->" + ipAddr + ":" + port);		new Thread(readBell).start();	}	private void init() throws IOException {		// 打开一个服务端通道		socketChannel = SocketChannel.open();		// 开启非堵塞模式		socketChannel.configureBlocking(false);		// 连接服务器		socketChannel.connect(new InetSocketAddress(ipAddr, port));		socketChannel.finishConnect();		sendBuffer = ByteBuffer.allocate(Integer.parseInt(ph.get(ConfigConts.BLOCK))); 	}					@Override	public void send(String msg) throws IOException {		if(null == socketChannel){			init();		}		System.out.println("sendMsg --> "+msg);		sendBuffer.put(msg.getBytes());		sendBuffer.flip();		socketChannel.write(sendBuffer);		sendBuffer.clear();	}	/**	 * 停止client	 */	@Override	public void stop() {		readBell.close();		System.exit(0);	}	/**	 * 服务器关闭事件	 * 	 * @param client	 * @throws IOException	 */	protected abstract void serverClose(SocketChannel client)			throws IOException;	/**	 * 接收到服务器发来的信息	 * 	 * @param client	 * @param receiveMsg	 * @throws IOException	 */	protected abstract void receiveMsg(SocketChannel client, String receiveMsg)			throws IOException;	protected void serverClose(SelectionKey key, SocketChannel client)			throws IOException {		System.out.println("server disconnect -->server that ip is ["				+ client.getRemoteAddress() + "] has been disconnected");		serverClose(client);		key.cancel();		client.close();	}	/**	 * Selector轮询线程类	 * 	 * @author cr	 */	class SelectorLoop implements Runnable {		private ByteBuffer receivebuffer = ByteBuffer.allocate(Integer				.parseInt(ph.get(ConfigConts.BLOCK)));		private Selector selector;		public SelectorLoop() throws IOException {			this.selector = Selector.open();		}		public Selector getSelector() {			return this.selector;		}		public void close() {			try {				this.selector.close();			} catch (IOException e) {				e.printStackTrace();			}		}		/**		 * 监听		 */		@Override		public void run() {			while (true) {				try {					// 阻塞,只有当至少一个注册的事件发生的时候才会继续.					this.selector.select();					Set<SelectionKey> selectKeys = this.selector.selectedKeys();					Iterator<SelectionKey> it = selectKeys.iterator();					while (it.hasNext()) {						SelectionKey key = it.next();						it.remove();						this.handleKey(key);					}				} catch (IOException e) {					e.printStackTrace();				} catch (InterruptedException e) {					e.printStackTrace();				}			}		}		/**		 * 事件的处理		 * 		 * @param key		 * @throws IOException		 * @throws InterruptedException		 */		public void handleKey(SelectionKey key) throws IOException,				InterruptedException {			if (key.isReadable()) {				// 这是一个read事件,并且这个事件是注册在socketchannel上的.				SocketChannel client = (SocketChannel) key.channel();				// 写数据到buffer				int count;				try {					count = client.read(receivebuffer);				} catch (IOException e) {					count = -1;				}				if (count < 0) {					serverClose(key, client);					return;				}				// 切换buffer到读状态,内部指针归位.				receivebuffer.flip();				String msg = Charset.forName("UTF-8").decode(receivebuffer)						.toString();				System.out.println("receive message -->"						+ client.getRemoteAddress() + ":" + msg);				// 清空buffer				receivebuffer.clear();				receiveMsg(client, msg);			}		}	}	public static PropertiesHandler ph;	static {		ph = new PropertiesHandler();	}}